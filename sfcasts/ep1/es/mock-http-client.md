# Ya está. Tener la capacidad de utilizar mocking su prueba es realmente impresionante, pero

mocking es un poco raro y complejo. No es tan sencillo como utilizar el objeto real normal para mantener esta complejidad al mínimo. Sólo debemos burlar los objetos que sean complejos y que no nos resulten fáciles de iniciar y controlar. Si nos fijamos en nuestra prueba del dinosaurio, sabemos que podríamos haber imitado el objeto dinosaurio aquí, pero eso es añadir líneas de código adicionales y no tiene ningún beneficio real. Sólo hace que nuestras pruebas sean más difíciles de leer. Y cuando podríamos haber utilizado el objeto real en su lugar, la regla general es esperar. No, pero si comparamos nuestro servicio con el HTP falso, con nuestro cliente HTTP, el registrador y la respuesta, estas clases, si intentamos utilizar los objetos reales, podría ser un poco difícil y no podemos controlarlos como hemos visto antes. Así que la regla general es que te burles de los servicios, no de los modelos. Por supuesto, hay excepciones a esta regla, pero no, y por supuesto hay excepciones a esta regla. Muy bien. Así que el cliente HTP de Symfony es, efectivamente, un servicio, pero la biblioteca viene con dos clases reales hechas específicamente para probar el cliente HTTP simulado y la respuesta simulada.

Estas dos clases son objetos simulados preconfigurados que funcionan directamente, pero no es necesario utilizarlos juntos. Podemos utilizarlos en cualquier tipo de prueba en lugar de un cliente HTTP real. Sigamos adelante y limpiemos nuestra, eh, excepción de prueba, lánzala con un método sin etiqueta, eh, muy rápido. Para empezar, vamos a eliminar, eh, para empezar, vamos a, en lugar de utilizar el, o crear un simulacro basado en la interfaz de respuesta, vamos a cambiar esto por un nuevo simulacro de respuesta dentro de esa respuesta. Tenemos que proporcionar un, eh, o tenemos que proporcionar el cuerpo de nuestra respuesta. Así que recuerda que GitHub nos devuelve J. Así que vamos a hacer lo mismo aquí. Vamos a JSON y el código y la matriz. Y dentro del vamos a pasar nuestro tema que estamos probando. ¿ok? Y podemos eliminar esta, uh, esta configuración aquí y para nuestro cliente HTTP falso, podemos hacer lo mismo. Así que vamos a deshacernos de esto aquí arriba, y vamos a llevar esto a = nuevo simulacro = nuevo cliente HTTP falso. Y sólo tenemos que pasar la respuesta que queremos que nos devuelva nuestro cliente.

Muy bien. Así que ahora tenemos nuestro cliente falso. Tenemos nuestro servicio y te das cuenta de que no estamos haciendo nada con este registrador aquí arriba. Así que en lugar de establecer el registrador en disponible, vamos a seguir adelante y cortar el, eh, el simulacro donde creamos el simulacro eliminar esta línea. Y aquí abajo, en nuestro servicio, simplemente pasaremos la, eh, llamada al método de creación del simulacro, eh, directamente a nuestro servicio. Bueno, esto ya se ve mejor. Pasemos a la, eh, CLI y escribamos vendor, bin PHP, unit, vendor, bin, PHP, unit, impresionante, 10 pruebas y 16 aserciones. Esto es superguay. Puedes notar que nuestra prueba de aserción bajó de 17 a 16, y eso es porque ya no estamos realizando, eh, el autoexamen de expectativas una vez en nuestro HT o en nuestro cliente HTTP falso. Y eso está muy bien si realmente necesitabas usar esto. No, eso es porque ninguno de estos simulacros realiza ninguna aserción por sí mismo como expects self. Una vez. Si miramos en nuestro método de prueba de arriba, podemos ver que estamos llamando a accepts self una vez, y esto es en realidad una aserción, el simulacro de cliente HT GB, y el simulacro de respuesta. No pueden realizar esas mismas aserciones.

Simplemente actúan como sustitutos silenciosos configurables de una interfaz de cliente HTTV para mostrarte, eh, pero la contrapartida de no poder usarlos es que echemos un vistazo a un diff y vayamos a la derecha, hagamos clic en nuestra prueba de servicio de GitHub, obtengamos y mostremos diff cerraremos. Cerraremos nuestro árbol de fuentes por aquí. Y mira esto. Empezamos mirando cuánto código hemos eliminado. Hemos reducido nuestra clase de prueba sólo con el uso de los mocks de Symfony en unas 11 líneas. Eso está muy bien. Muy bien. Y creo que eso es todo. Así que hecho.
