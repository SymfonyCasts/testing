# Partial Mocking

Let's make our `LockDownHelper` more *interesting*. Let's say that, when a lockdown ends, we need to send an API request to GitHub. In our *first* tutorial, we wrote code that made some API requests to ask things about this `SymfonyCasts/dino-park` repository. In *this* situation, we're going to *pretend* that, when we end a lockdown, we need to send an API request to find all of the issues with some "lockdown" label and *close* them. We're not *actually* going to do this but we'll go through the motions because this is going to create a really interesting situation.

In the *previous* tutorial, we made a GitHub service that wraps the API calls. The one method it currently has grabs a health report for all of our dinosaurs. Let's add a *new* `public function` here called `clearLockDownAlerts()`. Inside, we're not actually going to make any API calls. We *could*, but we're just going to simulate it with a log. Add a log message... and this is where we're going to use our imagination and *act* like we're making an API call. Cool! We'll also pretend that we've already tested this in some way - unit tests, integration tests, etc. The *point* is that we're *confident* that this method *definitely* works.

Over in `LockDownHelper.php`, let's *use* this. We can autowire `GithubService $githubService`... and down here, after we `flush()`, say `$this->githubservice->clearLockDownAlerts()`. Okay, let's try the test! We haven't changed our asserting at all, and... it *still* passes. That makes sense. In our test, we're asking Symfony for our `LockDownHelper`, so it's going to handle passing us the new `GithubService` argument. And since our GitHub service isn't *actually* making a real API call, everything's *fine*.

*But* what if `GithubService` *did* contain the real logic to make an actual HTTP request over to GitHub? *That* could cause a few problems. First, it would definitely slow down our test because API recalls are *slow*. Second, it might *fail* because, when it checks our repository, we may not have any issues with this `LockDown` label on it. And *third*, if it *does* find issues with a `LockDown` label, it might close them on our *real* production repository even though this is just a test. Furthermore, if we wanted to test that `clearLockDownAlerts()` was actually *called*, in an integration test, the only way to do that is by making an API call from our test that *seeded* our repository with some issues (*creating* an issue with a `LockDown` label), then *called* our method, and made *another* API request from our test to verify that the issue is gone. *Yikes*. That's *too* much work, when all we really want to do from our test is assert that this method *was called*.

If you'll recall from our unit testing tutorial, that's *exactly* why we use mocks. We avoid all of this nonsense around classes *actually* making API calls or *actually* talking to the database. We want to *simplify* all of that and just boil things down to asserting that certain methods were called. *So*, effectively, what we want to do is mock our *one* dependency, but use the *real* services for our *other* dependencies. The solution? Something really cool called "partial mocking".

When we ask the container for our `$lockDownHelper` service, it's going to instantiate the *real* services and pass them to each of our three arguments. What we *really* want to do is have it pass the *real* service for `$lockDownRepository` and `$entityManager`, but a *mock* for `$githubService`. Symfony actually gives us a way to do that - replacing a *real* service in the container with a *mock* during an integration test. How? Check this out!

*Before* we ask for our `$lockdownHelperService`, we need to create a `$githubService` mock, so say `$githubService = $this->createMock(GitbugService::class)`. Below that, we'll say `$githubService->expects()`, and to make sure this fails at first, let's say `$this->never()`. Finally, we'll say `->method('clearLockDownAlerts)`. So this will be called *once* and we're making sure it fails. If we stop now and run the test, it *will* still pass. We created a mock, but no one is *using* this yet. We need to tell Symfony:

`Hey! We want to replace the GithubService in the container with this mock`.

The way we do that is very simple - with `self::getContainer()->set()` - and then we're going to pass the ID of our service, which is `GithubService::class, $githubService`. Suddenly, *that* becomes the service in the container, and *that* is what will be passed to our `$lockDownHelper` as the *third* argument. *Now*, because we have this `never()`, when we run the test... it *fails*. It failed at `clearLockDownAlerts()` because it was *not* expected to be called, but it *was* called, since we're calling it down here. If we change this test from `$this->never()` to `$this->once()` and try again... it *passes*. This is *such* a cool strategy when you have this situation.

Next: Let's look at how we can test if our app caused something *external* to happen. Specifically, let's learn how to assert that our *code* sent an email.
